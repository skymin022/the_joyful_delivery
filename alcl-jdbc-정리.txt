-- alcl-jdbc í´ë” ë‚´ 
sql í´ë”ì™€ javaí´ë”ë¡œ êµ¬ì„± 

-- board.sql 
DROP TABLE IF EXISTS board;
CREATE TABLE board (
    no INT AUTO_INCREMENT PRIMARY KEY COMMENT 'PK',
    id VARCHAR(64) NOT NULL UNIQUE COMMENT 'UK',
    title VARCHAR(255) NOT NULL COMMENT 'ì œëª©',
    writer VARCHAR(100) NOT NULL COMMENT 'ì‘ì„±ì PK',
    content TEXT NOT NULL COMMENT 'ë‚´ìš©',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'ì‘ì„±ì¼',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'ìˆ˜ì •ì¼'
) COMMENT 'ê²Œì‹œíŒ';


INSERT INTO board (id, title, writer, content) VALUES
(UUID(), 'ì²« ë²ˆì§¸ ê¸€ ì œëª©', 'writer01', 'ì²« ë²ˆì§¸ ê¸€ ë‚´ìš©ì…ë‹ˆë‹¤.'),
(UUID(), 'ë‘ ë²ˆì§¸ ê¸€ ì œëª©', 'writer02', 'ë‘ ë²ˆì§¸ ê¸€ ë‚´ìš©ì…ë‹ˆë‹¤.'),
(UUID(), 'ì„¸ ë²ˆì§¸ ê¸€ ì œëª©', 'writer03', 'ì„¸ ë²ˆì§¸ ê¸€ ë‚´ìš©ì…ë‹ˆë‹¤.'),
(UUID(), 'ë„¤ ë²ˆì§¸ ê¸€ ì œëª©', 'writer04', 'ë„¤ ë²ˆì§¸ ê¸€ ë‚´ìš©ì…ë‹ˆë‹¤.'),
(UUID(), 'ë‹¤ì„¯ ë²ˆì§¸ ê¸€ ì œëª©', 'writer05', 'ë‹¤ì„¯ ë²ˆì§¸ ê¸€ ë‚´ìš©ì…ë‹ˆë‹¤.');

-- db_aloha sql
CREATE SCHEMA IF NOT EXISTS aloha
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

-- id_aloha sql 
CREATE USER 'aloha'@'%' IDENTIFIED BY '123456';

GRANT ALL PRIVILEGES ON *.* TO 'aloha'@'%' WITH GRANT OPTION;

FLUSH PRIVILEGES;

-- test sql 


DROP TABLE IF EXISTS test;
CREATE TABLE test (
	`no`   INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(100) NOT NULL,
	`age`  INT NULL DEFAULT 1,
	`main_title` TEXT NULL
);

SELECT *
FROM test
;

-- java í´ë” ë‚´ 
jdbc í´ë”, test í´ë” , db.properties íŒŒì¼ ì¡´ì¬

-- jdbc í´ë” ë‚´
annotation í´ë”, config í´ë”, dao í´ë”, dto í´ë”, utils í´ë”

--annotation í´ë” ë‚´ 
-- column.java 
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    boolean exist() default true;
}

-- Pk.java
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Pk {
	
}

-- Table.java
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
	String value();
}



--  config í´ë” ë‚´

-- config.java
package com.alohaclass.jdbc.config;

import java.io.InputStream;
import java.util.Properties;


public class Config {
    public static boolean mapUnderscoreToCamelCase = false;
    public static boolean mapCamelCaseToUnderscore = false;
    public static boolean autoCommit = true;
    public static boolean sqlLog = true;
    public static String url = null;
    public static String username = null;
    public static String password = null;
   
    static {
        try (InputStream input = Config.class.getClassLoader().getResourceAsStream("db.properties")) {
            Properties prop = new Properties();
            if (input == null) {
                System.out.println("Sorry, unable to find db.properties");
            }
            prop.load(input);
            url = prop.getProperty("db.url");
            username = prop.getProperty("db.username");
            password = prop.getProperty("db.password");
            mapUnderscoreToCamelCase = Boolean.parseBoolean(prop.getProperty("mapUnderscoreToCamelCase", "false"));
            mapCamelCaseToUnderscore = Boolean.parseBoolean(prop.getProperty("mapCamelCaseToUnderscore", "false"));
            sqlLog = Boolean.parseBoolean(prop.getProperty("sql.log", "true"));
            autoCommit = Boolean.parseBoolean(prop.getProperty("autoCommit", "true"));
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}

--  dao í´ë” ë‚´ 

-- BaseDAO.java
package com.alohaclass.jdbc.dao;

import java.sql.ResultSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;

/**
 * BaseDAO - DAO
 */
public interface BaseDAO<T> {

	// í…Œì´ë¸”ëª…
	String table();

	// PK (no or id)
	String pk();

	// ë§¤í•‘
	T map(ResultSet rs) throws Exception;

	// ê²€ìƒ‰ì˜µì…˜ ì¡°ê±´
//	String getSearchOptions(List<String > searchOptions) throws Exception;
	default String getSearchOptions(List<String> searchOptions) throws Exception {
		if (searchOptions == null || searchOptions.size() == 0) {
			return "1=1";
		}
		String str = "";
		for (Iterator iterator = searchOptions.iterator(); iterator.hasNext();) {
			String column = (String) iterator.next();
			str += (column + " LIKE CONCAT('%', ?, '%') ");
			if (iterator.hasNext())
				str += " OR ";
		}
		return str;
	}

	// í•„í„°ì˜µì…˜ ì •ë ¬
//	String getFilterOptions(Map<String, String> filterOptions) throws Exception;
	default String getFilterOptions(Map<String, String> filterOptions) throws Exception {
		String str = " ORDER BY ";
		Set<String> keys = filterOptions.keySet();
		for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
			String key = (String) iterator.next();
			String value = filterOptions.get(key);
			str += (key + " " + value); // title ASC, writer DESC ...
			if (iterator.hasNext())
				str += ", ";
		}
		return str;
	}

	// ëª©ë¡
	List<T> list() throws Exception;

	List<T> listBy(Map<String, Object> fields) throws Exception;

	// í˜ì´ì§•
	PageInfo<T> page() throws Exception;

	PageInfo<T> page(PageInfo<T> pageInfo) throws Exception;

	PageInfo<T> page(Page page) throws Exception;

	PageInfo<T> page(Page page, Map<String, String> filterOptions) throws Exception;

	PageInfo<T> page(Page page, String keyword, List<String> searchOptions) throws Exception;

	PageInfo<T> page(Page page, String keyword, List<String> searchOptions, Map<String, String> filterOptions)
			throws Exception;

	/**
	 * select - pk ê¸°ì¤€ìœ¼ë¡œ ì¡°íšŒ
	 * 
	 * @param pk
	 * @return
	 * @throws Exception
	 */
	T select(Object pk) throws Exception;

	/**
	 * selectBy - 1ê°œ ì´ìƒì˜ í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°íšŒ
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T selectBy(Map<String, Object> fields) throws Exception;

	/**
	 * where == selectBy - ì´ë¦„ë§Œ ì‰½ê²Œ
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T where(Map<String, Object> fields) throws Exception;

	List<T> in(String col, String fields) throws Exception;

	List<T> in(String col, String... field) throws Exception;

	List<T> in(String col, List<String> fieldList) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String fields) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String... field) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, List<String> fieldList) throws Exception;

	/**
	 * insert - null ì´ ì•„ë‹Œ í•„ë“œë§Œ insert
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int insert(T entity) throws Exception;

	/**
	 * insert - ì§€ì •í•œ í•„ë“œë§Œ insert
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int insert(T entity, String... fieldNames) throws Exception;

	/**
	 * insertKey - insert í›„, ìƒì„±ëœ key ë¥¼ ê°ì²´ì— ì§€ì •í•˜ì—¬ ë°˜í™˜
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	T insertKey(T entity) throws Exception;

	/**
	 * insertKey - ì§€ì •í•œ í•„ë“œë§Œ insert, ìƒì„±ëœ key ë¥¼ ê°ì²´ì— ì§€ì •í•˜ì—¬ ë°˜í™˜
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T insertKey(T entity, String... fieldNames) throws Exception;

	/**
	 * update - pk ì¡°ê±´ìœ¼ë¡œ update
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int update(T entity) throws Exception;

	/**
	 * update - ì§€ì •í•œ í•„ë“œë§Œ update
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int update(T entity, String... fields) throws Exception;
	
	/**
	 * update - 1ê°œ ì´ìƒì˜ í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°íšŒ
	 * @param entity
	 * @param map
	 * @return
	 * @throws Exception
	 */
	int updateBy(T entity, Map<String, Object> map) throws Exception;

	/**
	 * delete - pk ë¥¼ ê¸°ì¤€ìœ¼ë¡œ delete
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int delete(Object pk) throws Exception;

	/**
	 * delete - 1ê°œ ì´ìƒì˜ í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‚­ì œ
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int deleteBy(Map<String, Object> fields) throws Exception;

	/**
	 * ê°œìˆ˜ - ì „ì²´
	 * 
	 * @return
	 * @throws Exception
	 */
	int count() throws Exception;

	/**
	 * ê°œìˆ˜ - í˜ì´ì§•(ê²€ìƒ‰) ì¡°ê±´
	 * 
	 * @param pageInfo
	 * @return
	 * @throws Exception
	 */
	int count(PageInfo<T> pageInfo) throws Exception;

	/**
	 * ê°œìˆ˜ - ê²€ìƒ‰ ì¡°ê±´
	 * 
	 * @param keyword
	 * @param searchOptions
	 * @return
	 * @throws Exception
	 */
	int count(String keyword, List<String> searchOptions) throws Exception;

}


-- BaseDAOImpl.java
package com.alohaclass.jdbc.dao;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.annotation.Column;
import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;
import com.alohaclass.jdbc.config.Config;
import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.jdbc.utils.StringUtil;

public abstract class BaseDAOImpl<T> extends JDBConnection implements BaseDAO<T> {

	public String table() {
		// ì œë„¤ë¦­ íƒ€ì… Tì˜ ì‹¤ì œ í´ë˜ìŠ¤ ì–»ê¸°
		Class<T> clazz = getGenericType();

		// ì–´ë…¸í…Œì´ì…˜ì—ì„œ í…Œì´ë¸” ì´ë¦„ ì¶”ì¶œ
		if (clazz.isAnnotationPresent(Table.class)) {
			Table table = clazz.getAnnotation(Table.class);
			return table.value();
		}

		throw new IllegalStateException("í´ë˜ìŠ¤ " + clazz.getSimpleName() + "ì— @Table ì–´ë…¸í…Œì´ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.");
	}

	public String pk() {
		Class<T> clazz = getGenericType();
		for (Field field : clazz.getDeclaredFields()) {
			if (field.isAnnotationPresent(Pk.class)) {
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				return fieldName;
			}
		}
		throw new IllegalStateException("í´ë˜ìŠ¤ " + clazz.getSimpleName() + "ì— @Pk í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.");
	}

	@SuppressWarnings("unchecked")
	private Class<T> getGenericType() {
		return (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
	}

	public T map(ResultSet rs) throws Exception {
		ParameterizedType superclass = (ParameterizedType) getClass().getGenericSuperclass();
		Class<T> clazz = (Class<T>) superclass.getActualTypeArguments()[0];
		T entity = clazz.getDeclaredConstructor().newInstance();
		Field[] fields = clazz.getDeclaredFields();
		for (Field field : fields) {
			field.setAccessible(true);
			// @Column(exist = false)ì´ë©´ skip
			Column annotation = field.getAnnotation(Column.class);
			if (annotation != null && !annotation.exist()) {
				continue;
			}
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (field.getType().equals(String.class)) {
				field.set(entity, rs.getString(fieldName));
			} else if (field.getType().equals(Boolean.class) || field.getType().equals(boolean.class)) {
				field.set(entity, rs.getBoolean(fieldName));
			} else if (field.getType().equals(Long.class) || field.getType().equals(long.class)) {
				field.set(entity, rs.getLong(fieldName));
			} else if (field.getType().equals(Integer.class) || field.getType().equals(int.class)) {
				field.set(entity, rs.getInt(fieldName));
			} else if (field.getType().equals(Date.class)) {
				field.set(entity, rs.getTimestamp(fieldName));
			} else if (field.getType().equals(Double.class) || field.getType().equals(double.class)) {
				field.set(entity, rs.getDouble(fieldName));
			} else if (field.getType().equals(Float.class) || field.getType().equals(float.class)) {
				field.set(entity, rs.getFloat(fieldName));
			}
		}
		return entity;
	}

	@Override
	public List<T> list() throws Exception {
		String sql = " SELECT * FROM " + table();
		List<T> list = new ArrayList<T>();
		try {
			stmt = con.createStatement();
			log(sql);
			rs = stmt.executeQuery(sql);
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - list() ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> listBy(Map<String, Object> fields) throws Exception {
		StringBuilder sql = new StringBuilder("SELECT * FROM " + table() + " WHERE ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			String fieldName = entry.getKey();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(fieldName).append(" = ?");
			first = false;
		}

		List<T> list = new ArrayList<>();
		try {
			psmt = con.prepareStatement(sql.toString());

			int index = 1;
			StringBuilder paramLog = new StringBuilder("param (?) : ");
			for (Object value : fields.values()) {
				paramLog.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}

			log(sql, paramLog);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			return list;
		} catch (Exception e) {
			System.err.println(table() + " - listBy(Map<String, Object> fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public PageInfo<T> page() throws Exception {
		int total = count();
		Page page = new Page(total);

		String sql = " SELECT * FROM " + table() + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(PageInfo<T> pageInfo) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1" + "   AND ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count();
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String sql = " SELECT * " + " FROM " + table() + " LIMIT ?, ? ";
		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, Map<String, String> filterOptions) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count();
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String orderBy = getFilterOptions(filterOptions);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + orderBy + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, filterOptions) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, String keyword, List<String> searchOptions) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count(keyword, searchOptions);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(searchOptions);
		int searchCounditionCount = searchOptions == null ? 0 : searchOptions.size();
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1" + "   AND ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, keyword, searchOptions) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, String keyword, List<String> searchOptions, Map<String, String> filterOptions)
			throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count(keyword, searchOptions);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}

		String searchCondition = getSearchOptions(searchOptions);
		String AND = " AND ( " + searchCondition + " )";

		if ((keyword == null || keyword.equals("")) || (searchOptions == null || searchOptions.size() == 0)) {
			AND = "";
		}
		int searchCounditionCount = searchOptions == null ? 0 : searchOptions.size();
		String orderBy = getFilterOptions(filterOptions);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + AND + orderBy + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);

			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, keyword, searchOptions, filterOptions) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public T select(Object pk) throws Exception {
		String sql = "SELECT * FROM " + table() + " WHERE " + pk() + " = ?";
		StringBuilder param = new StringBuilder("param (?) : (1)").append(pk.toString()).append(" ");

		try {
			psmt = con.prepareStatement(sql);
			setPreparedStatementValue(psmt, 1, pk); // ì¤‘ë³µ ì œê±°
			log(new StringBuilder(sql), param);

			rs = psmt.executeQuery();
			if (rs.next()) {
				return map(rs); // ì¡°íšŒëœ row -> entityë¡œ ë³€í™˜
			}
		} catch (Exception e) {
			System.err.println(table() + " - select(pk) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public T where(Map<String, Object> fields) throws Exception {
		return selectBy(fields);
	}

	@Override
	public T selectBy(Map<String, Object> fields) throws Exception {
		StringBuilder sql = new StringBuilder("SELECT * FROM " + table() + " WHERE ");
		StringBuilder param = new StringBuilder("param (?) : ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(entry.getKey()).append(" = ?");
			first = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());

			int index = 1;
			for (Map.Entry<String, Object> entry : fields.entrySet()) {
				Object value = entry.getValue();
				param.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°
			}

			log(sql, param);

			rs = psmt.executeQuery();
			if (rs.next()) {
				return map(rs);
			}
		} catch (Exception e) {
			System.err.println(table() + " - selectBy(Map<String, Object>) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * IN ì¡°ê±´ ê°’ë“¤ì„ '' ë¡œ ë¬¶ì–´ì„œ ë°˜í™˜
	 * 
	 * @param col
	 * @param fields
	 * @return
	 */
	private String getInCondition(String col, String fields) {
		if (fields == null || fields.isEmpty()) {
			return "";
		}
		if (!fields.contains(",")) {
			return "AND " + col + " IN ( '" + fields + "' ) ";
		}
		String[] fieldArray = fields.split(",");
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fieldArray) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	private String getInConditions(String col, String... fields) {
		if (fields == null || fields.length == 0) {
			return "";
		}
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fields) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	private String getInConditions(String col, List<String> fieldList) {
		if (fieldList == null || fieldList.isEmpty()) {
			return "";
		}
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fieldList) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	@Override
	public List<T> in(String col, String fields) throws Exception {
		String IN = getInCondition(col, fields);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> in(String col, String... field) throws Exception {
		String IN = getInConditions(col, field);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> in(String col, List<String> fieldList) throws Exception {
		String IN = getInConditions(col, fieldList);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String fields) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInCondition(col, fields);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String... field) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInConditions(col, field);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, List<String> fieldList) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInConditions(col, fieldList);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public int insert(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		for (Field field : fields) {
			field.setAccessible(true);

			Column tableField = field.getAnnotation(Column.class);
			if (tableField != null && !tableField.exist()) {
				continue;
			}

			Object value = field.get(entity);

			if (value != null && !isDefaultValue(value)) {
				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;

			for (Field field : fields) {
				field.setAccessible(true);

				Column tableField = field.getAnnotation(Column.class);
				if (tableField != null && !tableField.exist()) {
					continue;
				}

				Object value = field.get(entity);

				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°
				}
			}
			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	private boolean isDefaultValue(Object value) {
		if (value instanceof Long) {
			return (Long) value == 0;
		} else if (value instanceof Boolean) {
			return !(Boolean) value;
		} else if (value instanceof Integer) {
			return (Integer) value == 0;
		} else if (value instanceof Double) {
			return (Double) value == 0.0;
		} else if (value instanceof Float) {
			return (Float) value == 0.0f;
		}
		return false;
	}

	@Override
	public int insert(T entity, String... fieldNames) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;
		for (String fieldName : fieldNames) {
			Field field = fieldMap.get(fieldName);
			if (field != null) {
				Column tableField = field.getAnnotation(Column.class);
				if (tableField != null && !tableField.exist()) {
					continue; // DBì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•„ë“œëŠ” ê±´ë„ˆëœ€
				}

				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}

				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;

			for (String fieldName : fieldNames) {
				Field field = fieldMap.get(fieldName);
				if (field != null) {
					Column tableField = field.getAnnotation(Column.class);
					if (tableField != null && !tableField.exist()) {
						continue;
					}

					field.setAccessible(true);
					Object value = field.get(entity);

					setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°!
				}
			}
			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity, String...) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public T insertKey(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		for (Field field : fields) {
			field.setAccessible(true);

			// ğŸ”¹ TableField(exist = false) í•„ë“œ ê±´ë„ˆë›°ê¸°
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			Object value = field.get(entity);
			if (value != null && !isDefaultValue(value)) {
				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			// ğŸ”¹ PreparedStatement ìƒì„±
			// ğŸ”¸ Statement.RETURN_GENERATED_KEYS ì˜µì…˜ì„ ì‚¬ìš©í•˜ì—¬ AUTO_INCREMENT í‚¤ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë„ë¡ ì„¤ì •
			psmt = con.prepareStatement(sql.toString(), Statement.RETURN_GENERATED_KEYS);
			int index = 1;

			for (Field field : fields) {
				field.setAccessible(true);

				// ğŸ”¹ TableField(exist = false) í•„ë“œ ê±´ë„ˆë›°ê¸°
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				Object value = field.get(entity);
				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°!
				}
			}

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}

		// ğŸ”¹ AUTO_INCREMENT key ì„¤ì •
		Long genKey = 0L;
		try (ResultSet generatedKeys = psmt.getGeneratedKeys()) {
			if (generatedKeys.next()) {
				genKey = generatedKeys.getLong(1);
				// Underscore to CamelCase ë³€í™˜
				String pk = pk();
				if (Config.mapUnderscoreToCamelCase) {
					pk = StringUtil.convertUnderscoreToCamelCase(pk);
				}
				Field pkField = entity.getClass().getDeclaredField(pk);
				pkField.setAccessible(true);
				if (pkField.getType().equals(Long.class) || pkField.getType().equals(long.class)) {
					pkField.set(entity, genKey);
				} else if (pkField.getType().equals(Integer.class) || pkField.getType().equals(int.class)) {
					pkField.set(entity, genKey.intValue());
				} else if (pkField.getType().equals(String.class)) {
					pkField.set(entity, genKey.toString());
				} else {
					pkField.set(entity, genKey);
				}
				System.out.println("genKey : " + genKey);
			}
		} catch (Exception e) {
			System.err.println(table() + " - insertKey(entity) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}

		return entity;
	}

	@Override
	public T insertKey(T entity, String... fieldNames) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;
		for (String fieldName : fieldNames) {
			Field field = fieldMap.get(fieldName);
			if (field == null)
				continue;

			// ğŸ”¹ TableField(exist = false) í•„ë“œ ì œì™¸
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			if (!first) {
				sql.append(", ");
				placeholders.append(", ");
			}

			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}

			sql.append(fieldName);
			placeholders.append("?");
			first = false;
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString(), Statement.RETURN_GENERATED_KEYS);
			int index = 1;

			for (String fieldName : fieldNames) {
				Field field = fieldMap.get(fieldName);
				if (field == null)
					continue;

				// ğŸ”¹ TableField(exist = false) í•„ë“œ ì œì™¸
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				field.setAccessible(true);
				Object value = field.get(entity);
				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°!
				}
			}

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity, String...) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}

		// AUTO_INCREMENT key ì²˜ë¦¬
		Long genKey = 0L;
		try (ResultSet generatedKeys = psmt.getGeneratedKeys()) {
			if (generatedKeys.next()) {
				genKey = generatedKeys.getLong(1);
				Field pkField = entity.getClass().getDeclaredField(pk());
				pkField.setAccessible(true);
				if (pkField.getType().equals(Long.class) || pkField.getType().equals(long.class)) {
					pkField.set(entity, genKey);
				} else if (pkField.getType().equals(Integer.class) || pkField.getType().equals(int.class)) {
					pkField.set(entity, genKey.intValue());
				} else if (pkField.getType().equals(String.class)) {
					pkField.set(entity, genKey.toString());
				} else {
					pkField.set(entity, genKey);
				}
				System.out.println("genKey : " + genKey);
			}
		} catch (Exception e) {
			System.err.println(table() + " - insertKey(entity) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}

		return entity;
	}

	@Override
	public int update(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		StringBuilder whereClause = new StringBuilder(" WHERE " + pk() + " = ?");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;
		Object pkValue = null;

		for (Field field : fields) {
			field.setAccessible(true);

			// ğŸ”¹ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•„ë“œ ì œì™¸
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			Object value = field.get(entity);
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}

			if (fieldName.equals(pk())) {
				pkValue = value;
				continue;
			}

			if (value != null) {
				if (!first) {
					sql.append(", ");
				}
				sql.append(fieldName).append(" = ?");
				first = false;
			}
		}

		sql.append(whereClause);

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");

			for (Field field : fields) {
				field.setAccessible(true);

				// ğŸ”¹ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•„ë“œ ì œì™¸
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				Object value = field.get(entity);
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				if (fieldName.equals(pk())) {
					continue;
				}

				if (value != null) {
					param.append("(").append(index).append(")").append(value.toString()).append(" ");
					setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°!
				}
			}

			// WHERE ì ˆì˜ pk íŒŒë¼ë¯¸í„° ì„¸íŒ…
			param.append("(").append(index).append(")").append(pkValue.toString()).append(" ");
			setPreparedStatementValue(psmt, index, pkValue);

			log(sql, param, pkValue.toString());
			result = psmt.executeUpdate();

		} catch (Exception e) {
			System.err.println(table() + " - update(entity) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int update(T entity, String... fields) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		StringBuilder whereClause = new StringBuilder(" WHERE " + pk() + " = ?");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;

		for (String fieldName : fields) {
			if (fieldMap.containsKey(fieldName)) {
				Field field = fieldMap.get(fieldName);

				// ğŸ”¹ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•„ë“œ ì œì™¸
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				field.setAccessible(true);
				Object value = field.get(entity);

				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				if (value != null) {
					if (!first)
						sql.append(", ");
					sql.append(fieldName).append(" = ?");
					first = false;
				}
			}
		}

		sql.append(whereClause);

		Field pkField = fieldMap.get(pk());
		pkField.setAccessible(true);
		Object pkValue = pkField.get(entity);

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");

			for (String fieldName : fields) {
				if (fieldMap.containsKey(fieldName)) {
					Field field = fieldMap.get(fieldName);

					// ğŸ”¹ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•„ë“œ ì œì™¸
					Column tf = field.getAnnotation(Column.class);
					if (tf != null && !tf.exist())
						continue;

					field.setAccessible(true);
					Object value = field.get(entity);

					if (field.getName().equals(pk())) {
						continue;
					}

					if (Config.mapCamelCaseToUnderscore) {
						fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
					}

					if (value != null) {
						param.append("(").append(index).append(")").append(value.toString()).append(" ");
						setPreparedStatementValue(psmt, index++, value); // ì¤‘ë³µ ì œê±°!
					}
				}
			}

			// ğŸ”¸ WHERE ì ˆ pk ë°”ì¸ë”©
			param.append("(").append(index).append(")").append(pkValue.toString()).append(" ");
			if (pkValue instanceof String) {
				psmt.setString(index, (String) pkValue);
			} else if (pkValue instanceof Boolean) {
				psmt.setBoolean(index, (Boolean) pkValue);
			} else if (pkValue instanceof Long) {
				psmt.setLong(index, (Long) pkValue);
			} else if (pkValue instanceof Integer) {
				psmt.setInt(index, (Integer) pkValue);
			} else if (pkValue instanceof Double) {
				psmt.setDouble(index, (Double) pkValue);
			} else if (pkValue instanceof Float) {
				psmt.setFloat(index, (Float) pkValue);
			} else if (pkValue instanceof java.util.Date) {
				psmt.setDate(index, new java.sql.Date(((java.util.Date) pkValue).getTime()));
			} else {
				psmt.setObject(index, pkValue);
			}

			log(sql, param, pkValue.toString());
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - update(entity, String...) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}

		return result;
	}

	@Override
	public int updateBy(T entity, Map<String, Object> map) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		// SETì ˆ êµ¬ì„± (PK ì œì™¸, null ì œì™¸)
		for (Field field : fields) {
			field.setAccessible(true);
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (fieldName.equals(pk()))
				continue;
			Object value = field.get(entity);
			if (value != null) {
				if (!first)
					sql.append(", ");
				sql.append(fieldName).append(" = ?");
				first = false;
			}
		}

		// WHEREì ˆ êµ¬ì„±
		sql.append(" WHERE ");
		boolean firstCond = true;
		for (String key : map.keySet()) {
			String fieldName = key;
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!firstCond)
				sql.append(" AND ");
			sql.append(fieldName).append(" = ?");
			firstCond = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");
			// SETì ˆ íŒŒë¼ë¯¸í„° ë°”ì¸ë”©
			for (Field field : fields) {
				field.setAccessible(true);
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				if (fieldName.equals(pk()))
					continue;
				Object value = field.get(entity);
				if (value != null) {
					param.append("(").append(index).append(")").append(value).append(" ");
					setPreparedStatementValue(psmt, index++, value);
				}
			}
			// WHEREì ˆ íŒŒë¼ë¯¸í„° ë°”ì¸ë”©
			for (Object value : map.values()) {
				param.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}
			log(sql, param);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - updateBy(entity, map) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(Object pk) throws Exception {
		int result = 0;
		String sql = "DELETE FROM " + table() + " WHERE " + pk() + " = ?";

		try {
			psmt = con.prepareStatement(sql);
			setPreparedStatementValue(psmt, 1, pk); // ğŸ”¹ íƒ€ì…ë³„ ë¶„ê¸° ê³µí†µ ë©”ì„œë“œë¡œ ë¶„ë¦¬

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - delete(pk) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int deleteBy(Map<String, Object> fields) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("DELETE FROM " + table() + " WHERE ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			String fieldName = entry.getKey();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(fieldName).append(" = ?");
			first = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder paramLog = new StringBuilder("param (?) : ");

			for (Object value : fields.values()) {
				paramLog.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}

			log(sql, paramLog);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - deleteBy(Map<String, Object> fields) ë„ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int count() throws Exception {
		int total = 0;
		String sql = "SELECT COUNT(*) FROM " + table();
		try {
			stmt = con.createStatement();
			rs = stmt.executeQuery(sql);
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count() ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return total;
	}

	@Override
	public int count(PageInfo<T> pageInfo) throws Exception {
		int total = 0;
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchConditionCount = pageInfo.getSearchOptions().size();
		String sql = "SELECT COUNT(*) FROM " + table() + " WHERE 1=1 AND (" + searchCondition + ")";

		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchConditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			rs = psmt.executeQuery();
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count(PageInfo<T> pageInfo) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return total;
	}

	@Override
	public int count(String keyword, List<String> searchOptions) throws Exception {
		int total = 0;
		String searchCondition = getSearchOptions(searchOptions);
		int searchConditionCount = searchOptions == null ? 0 : searchOptions.size();
		String sql = "SELECT COUNT(*) FROM " + table() + " WHERE 1=1 AND (" + searchCondition + ")";

		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchConditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			rs = psmt.executeQuery();
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count(keyword, searchOptions) ì¡°íšŒ ì¤‘ ì—ëŸ¬");
			e.printStackTrace();
		}
		return total;

	}

	/**
	 * SQL ë¡œê·¸
	 * 
	 * @param sql
	 */
	public void log(String sql) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql.toString());
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql, StringBuilder param) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println(param.toString());
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql, StringBuilder param, String pk) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println(param.toString());
			System.out.println("pk - " + pk() + " : " + pk);
			System.out.println("==================================================");
		}
	}

	// ğŸ”¸ íƒ€ì… ë¶„ê¸° ê³µí†µí™”
	private void setPreparedStatementValue(PreparedStatement ps, int index, Object value) throws SQLException {
		if (value instanceof String) {
			ps.setString(index, (String) value);
		} else if (value instanceof Boolean) {
			ps.setBoolean(index, (Boolean) value);
		} else if (value instanceof Long) {
			ps.setLong(index, (Long) value);
		} else if (value instanceof Integer) {
			ps.setInt(index, (Integer) value);
		} else if (value instanceof Double) {
			ps.setDouble(index, (Double) value);
		} else if (value instanceof Float) {
			ps.setFloat(index, (Float) value);
		} else if (value instanceof Date) {
			Date dateValue = (Date) value;
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateValue);
			Timestamp timestampValue = new Timestamp(cal.getTimeInMillis());
			ps.setTimestamp(index, timestampValue);
		} else {
			ps.setObject(index, value);
		}
	}

}

-- JDBConnection.java
package com.alohaclass.jdbc.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;

import com.alohaclass.jdbc.config.Config;

public class JDBConnection {
    
    public Connection con;                // ì—°ê²°ëœ ë“œë¼ì´ë²„ì— SQLì„ ìš”ì²­í•  ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” í´ë˜ìŠ¤
    public Statement stmt;                // SQL ì‹¤í–‰ ìš”ì²­ì„ í•˜ëŠ” í´ë˜ìŠ¤
    public PreparedStatement psmt;        // Statement ì—ì„œ ? íŒŒë¼ë¯¸í„° í™•ì¥ê¸°ëŠ¥ì„ ì¶”ê°€ë¡œ ì œê³µí•˜ëŠ” í´ë˜ìŠ¤
    public ResultSet rs;                // SQL ì‹¤í–‰ ê²°ê³¼ë¥¼ ë°›ì•„ì˜¤ëŠ” í´ë˜ìŠ¤
    
    // ê¸°ë³¸ ìƒì„±ì
    public JDBConnection() {
        // JDBC ë“œë¼ì´ë²„ ë¡œë“œ
        // MySQL
        try {
            // mysql-connector-j.xxx.jar ë“œë¼ì´ë²„ì˜ í´ë˜ìŠ¤ë¥¼ ë¡œë“œí•œë‹¤.
            Class.forName("com.mysql.cj.jdbc.Driver");         
            con = DriverManager.getConnection(Config.url, Config.username, Config.password);
            // Auto Commit ì—¬ë¶€ ì„¤ì •
        	try {
    			con.setAutoCommit(Config.autoCommit);
    			// System.out.println("Auto Commit : " + Config.autoCommit);
        	} catch (Exception e) {
        		System.err.println("Auto Commit ì„¤ì • ì‹¤íŒ¨");
        	}
            	
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


-- dto í´ë” ë‚´ 

-- Entitiy.java 
package com.alohaclass.jdbc.dto;

import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;

public class Entity {
    public String tableName;
    public String pk;
    
    public Entity() {
		initializeTableName();
		initializePk();
	}
	
	public void initializePk() {
		// íŠ¹ì • ë³€ìˆ˜ ìœ„ì— @Pk ë¶™ì–´ ìˆìœ¼ë©´ ê·¸ ë³€ìˆ˜ë¥¼ pkë¡œ ì„¤ì •
		Class<?> clazz = this.getClass();
		if (clazz.isAnnotationPresent(Pk.class)) {
			Pk pk = clazz.getAnnotation(Pk.class);
			this.pk = pk.toString();
		}
	}
    
    public void initializeTableName() {
        Class<?> clazz = this.getClass();
        if (clazz.isAnnotationPresent(Table.class)) {
            Table table = clazz.getAnnotation(Table.class);
            this.tableName = table.value();
        }
    }
    

    public String getTableName() {
        return tableName;
    }

    public String getPk() {
        return pk;
    }
    
    
}




-- Page.java


--  utils í´ë”
package com.alohaclass.jdbc.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * [í˜ì´ì§•]
 * âœ… í˜ì´ì§€ í•„ìˆ˜ ì •ë³´
 * í˜ì´ì§€ ë²ˆí˜¸          : 
 * í˜ì´ì§€ë‹¹ ê²Œì‹œê¸€ ìˆ˜       
 * ë…¸ì¶œ í˜ì´ì§€ ê°œìˆ˜
 * ì „ì²´ ë°ì´í„° ê°œìˆ˜
 * 
 * â­ í˜ì´ì§€ ìˆ˜ì‹ ì •ë³´
 * ì‹œì‘ ë²ˆí˜¸
 * ë ë²ˆí˜¸
 * ì²« ë²ˆí˜¸
 * ë§ˆì§€ë§‰ ë²ˆí˜¸       
 */
@Data
@AllArgsConstructor
// @Builder  // ë²„ê·¸ë‚˜ëŠ” ë²„ì „ì´ ìˆì–´ì„œ ì œì™¸
public class Page {

    // í˜ì´ì§• ê¸°ë³¸ê°’
    public static final int PAGE = 1;  		// í˜„ì¬ í˜ì´ì§€ ë²ˆí˜¸ ê¸°ë³¸ê°’
    public static final int SIZE = 10;      // í˜ì´ì§€ë‹¹ ê²Œì‹œê¸€ ìˆ˜ ê¸°ë³¸ê°’
    public static final int COUNT = 10;     // ë…¸ì¶œ í˜ì´ì§€ ê°œìˆ˜ ê¸°ë³¸ê°’


    // âœ… í•„ìˆ˜ ì •ë³´
    private int page;   // í˜ì´ì§€ ë²ˆí˜¸
    private int size;   // í˜ì´ì§€ë‹¹ ê¸€ ìˆ˜
    private int count;  // ë…¸ì¶œ í˜ì´ì§€ ê°œìˆ˜
    private int total;  // ì „ì²´ ë°ì´í„° ê°œìˆ˜

    // â­ ìˆ˜ì‹ ì •ë³´
    private int start;  // ì‹œì‘ ë²ˆí˜¸
    private int end;    // ë ë²ˆí˜¸
    private int first;  // ì²« ë²ˆí˜¸
    private int last;   // ë§ˆì§€ë§‰ ë²ˆí˜¸

    private int prev;   // ì´ì „ ë²ˆí˜¸
    private int next;   // ë‹¤ìŒ ë²ˆí˜¸

    private int index;  // ë°ì´í„° ìˆœì„œ ë²ˆí˜¸

    // ìƒì„±ì
    public Page() {
        this(0);
    }

    // ë°ì´í„° ê°œìˆ˜
    public Page(int total) {
        this(PAGE, total);
    }

    // í˜„ì¬ ë²ˆí˜¸, ë°ì´í„° ê°œìˆ˜
    public Page(int page, int total) {
        this(page, SIZE, COUNT, total);
    }

    public Page(int page, int size, int count, int total) {
        this.page = page;
        this.size = size;
        this.count = count;
        this.total = total;
        calc();
    }

    // setter
    // - ë°ì´í„° ê°œìˆ˜ ì§€ì • í›„, í˜ì´ì§• ìˆ˜ì‹ ì¬ê³„ì‚°
    public void setTotal(int total) {
        this.total = total;
        calc();
    } 

    // í˜ì´ì§• ì²˜ë¦¬ ìˆ˜ì‹
    public void calc() {
        // ì²« ë²ˆí˜¸
        this.first = 1;
        // ë§ˆì§€ë§‰ ë²ˆí˜¸
        this.last = (this.total - 1) / size + 1;
        // ì‹œì‘ ë²ˆí˜¸
        this.start = ( (page-1) / count ) * count + 1;
        // ë ë²ˆí˜¸
        this.end = ( (page-1) / count + 1 ) * count;
        if( this.end > this.last ) this.end = this.last;

        // ì´ì „ ë²ˆí˜¸
        this.prev = this.page - 1;
        // ë‹¤ìŒ ë²ˆí˜¸
        this.next = this.page + 1;
        // ë°ì´í„° ìˆœì„œ ë²ˆí˜¸(index)
        this.index = (this.page - 1) * this.size;
    }
    
}

-- PageInfo.java
package com.alohaclass.jdbc.dto;

import java.util.List;
import java.util.Map;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * í˜ì´ì§•
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class PageInfo<T> {
	
	Page page;								// í˜ì´ì§•
	List<T> list;							// ë°ì´í„° ëª©ë¡
	String keyword;							// ê²€ìƒ‰ì–´
	List<String> searchOptions;		// ê²€ìƒ‰ ì˜µì…˜ (title, writer, content, ...)
    Map<String, String> filterOptions;		// í•„í„° ì˜µì…˜
    
}

-- utils í´ë” ë‚´ 

-- StringUtil.java
package com.alohaclass.jdbc.utils;

public class StringUtil {
	
	// camel --> underscore
	// * sampleObject --> sample_object
	public static String convertCamelCaseToUnderscore(String camelCase) {
        StringBuilder result = new StringBuilder();
        for (char c : camelCase.toCharArray()) {
            if (Character.isUpperCase(c)) {
                result.append('_').append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
	
	
	// underscore --> camel  
	// * sample_object --> sampleObject
	public static String convertUnderscoreToCamelCase(String underscore) {
		StringBuilder result = new StringBuilder();
		boolean nextUpperCase = false;
		for (char c : underscore.toCharArray()) {
			if (c == '_') {
				nextUpperCase = true;
			} else {
				if (nextUpperCase) {
					result.append(Character.toUpperCase(c));
					nextUpperCase = false;
				} else {
					result.append(c);
				}
			}
		}
		return result.toString();
	}
}



-- test í´ë” ë‚´

DAO í´ë”, DTO í´ë”, Service í´ë” ì¡´ì¬

-- DAO í´ë” ë‚´

-- BoardDAO.java
package com.alohaclass.test.DAO;


import com.alohaclass.jdbc.dao.BaseDAOImpl;
import com.alohaclass.test.DTO.Board;

public class BoardDAO extends BaseDAOImpl<Board> {

	

}


-- TestDAO.java 
package com.alohaclass.test.DAO;

import java.sql.ResultSet;

import com.alohaclass.jdbc.dao.BaseDAOImpl;
import com.alohaclass.test.DTO.Test;

public class TestDAO extends BaseDAOImpl<Test> {

	@Override
	public Test map(ResultSet rs) throws Exception {
		Test test = new Test();
		test.setName( rs.getString("name") );
		test.setAge( rs.getInt("age") );
		return test;
	}

	@Override
	public String pk() {
		return "no";
	}

	@Override
	public String table() {
		return "test";
	}

}


-- DTO í´ë” ë‚´

-- Board.java 
package com.alohaclass.test.DTO;

import java.util.Date;

import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;
import com.alohaclass.jdbc.annotation.Column;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Table("board")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Board {

	@Pk
	private Long boardNo;			// ê¸°ë³¸í‚¤
	private String id;
	private String title;
	private String writer;
	private String content;
	private Date date;
	private Date createdAt;
	private Date updatedAt;
	
	@Column(exist = false)		// ì‹¤ì œ DB ì»¬ëŸ¼ì— ì—†ëŠ” ë³€ìˆ˜
	private String test;
	

}


-- Test.java 
package com.alohaclass.test.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Test {
	private int no;
	private String name;
	private int age;
	private String mainTitle;
}


-- Service í´ë” ë‚´ 

-- BoardService.java 
package com.alohaclass.test.Service;

import java.util.List;

import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DTO.Board;

public interface BoardService {
	
	// C.R.U.D
	public List<Board> list();
	public PageInfo<Board> page();
	public Board select(int no);
	public Board selectById(String id);
	public int insert(Board Board);
	public Board insertKey(Board Board);
	public int update(Board Board);
	public int delete(int no);

}


-- BoardServiceImpl.java 
package com.alohaclass.test.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DAO.BoardDAO;
import com.alohaclass.test.DTO.Board;

public class BoardServiceImpl implements BoardService {
	
	BoardDAO boardDAO = new BoardDAO();

	@Override
	public List<Board> list() {
		List<Board> list = null;
		try {
			list = boardDAO.list();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}
	

	@Override
	public PageInfo<Board> page() {
		PageInfo<Board> pageInfo = null;
		try {
			Page page = new Page();
			page.setPage(1);
			page.setSize(10);
			// ë°©ë²•1
			// pageInfo = boardDAO.page();
			// ë°©ë²•2
			//pageInfo = testDAO.page(page);
			// ë°©ë²•3
			String keyword = "ê²€ìƒ‰ì–´";
			List<String> searchOptions = List.of("title", "content");
			// pageInfo = boardDAO.page(page, keyword, searchOptions);
			// ë°©ë²•4
			Map<String, String> filterOptions = new HashMap<String, String>() {{
	            put("title", "ASC");
	            put("writer", "DESC");
	        }};
	        boardDAO.page(page, keyword, searchOptions, filterOptions);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public Board select(int no) {
		Board board = null;
		try {
			board = boardDAO.select(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return board;
	}

	@Override
	public int insert(Board Board) {
		int result = 0;
		try {
			result = boardDAO.insert(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public Board insertKey(Board Board) {
		Board result = null;
		try {
			result = boardDAO.insertKey(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int update(Board Board) {
		int result = 0;
		try {
			result = boardDAO.update(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(int no) {
		int result = 0;
		try {
			result = boardDAO.delete(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}


	@Override
	public Board selectById(String id) {
		Board board = null;
		try {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("id", id);
			board = boardDAO.selectBy(map);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return board;
	} 

}

-- TestService.java 
package com.alohaclass.test.Service;

import java.util.List;

import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DTO.Test;

public interface TestService {
	
	// C.R.U.D
	public List<Test> list();
	public PageInfo<Test> page();
	public Test select(int no);
	public int insert(Test test);
	public Test insertKey(Test test);
	public int update(Test test);
	public int delete(int no);

}

-- TestServiceImpl.java 
package com.alohaclass.test.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DAO.TestDAO;
import com.alohaclass.test.DTO.Test;

public class TestServiceImpl implements TestService {
	
	TestDAO testDAO = new TestDAO();

	@Override
	public List<Test> list() {
		List<Test> list = null;
		try {
			list = testDAO.list();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}
	
	@Override
	public PageInfo<Test> page() {
		PageInfo<Test> pageInfo = null;
		try {
			// ë°©ë²•1
			// pageInfo = testDAO.page();
			// ë°©ë²•2
			 Page page = new Page();
			 page.setPage(1);
			 page.setSize(10);
			// pageInfo = testDAO.page(page);
			// ë°©ë²•3
			String keyword = "ê²€ìƒ‰ì–´";
			List<String> searchOptions = new ArrayList<String>();
			searchOptions.add("name");
			searchOptions.add("age");
			// pageInfo = testDAO.page(page, keyword, searchOptions);
			// ë°©ë²•4
			Map<String, String> filterOptions = new HashMap<String, String>() {{
	            put("name", "ASC");
	            put("age", "DESC");
	        }};
			testDAO.page(page, keyword, searchOptions, filterOptions);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public Test select(int no) {
		Test test = null;
		try {
			test = testDAO.select(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return test;
	}

	@Override
	public int insert(Test test) {
		int result = 0; 
		try {
			result = testDAO.insert(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
	
	@Override
	public Test insertKey(Test test) {
		try {
			test = testDAO.insertKey(test);
			System.out.println(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return test;
	}


	@Override
	public int update(Test test) {
		int result = 0;
		try {
			result = testDAO.update(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(int no) {
		int result = 0;
		try {
			result = testDAO.delete(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

}

-- db.properties 
db.url=jdbc:mysql://127.0.0.1:3306/aloha?serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true&useSSL=false
db.username=aloha
db.password=123456
mapUnderscoreToCamelCase=true
mapCamelCaseToUnderscore=true
autoCommit=true
sqlLog=true


ì‚¬ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” 
jakarta.servlet-api-6.1.0
jakarta.servlet.jsp.jstl-3.0.1
jakarta.servlet.jsp.jstl-api-3.0.2
lombok
mysql-connector-j-9.0.0

