-- alcl-jdbc 폴더 내 
sql 폴더와 java폴더로 구성 

-- board.sql 
DROP TABLE IF EXISTS board;
CREATE TABLE board (
    no INT AUTO_INCREMENT PRIMARY KEY COMMENT 'PK',
    id VARCHAR(64) NOT NULL UNIQUE COMMENT 'UK',
    title VARCHAR(255) NOT NULL COMMENT '제목',
    writer VARCHAR(100) NOT NULL COMMENT '작성자 PK',
    content TEXT NOT NULL COMMENT '내용',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '작성일',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일'
) COMMENT '게시판';


INSERT INTO board (id, title, writer, content) VALUES
(UUID(), '첫 번째 글 제목', 'writer01', '첫 번째 글 내용입니다.'),
(UUID(), '두 번째 글 제목', 'writer02', '두 번째 글 내용입니다.'),
(UUID(), '세 번째 글 제목', 'writer03', '세 번째 글 내용입니다.'),
(UUID(), '네 번째 글 제목', 'writer04', '네 번째 글 내용입니다.'),
(UUID(), '다섯 번째 글 제목', 'writer05', '다섯 번째 글 내용입니다.');

-- db_aloha sql
CREATE SCHEMA IF NOT EXISTS aloha
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

-- id_aloha sql 
CREATE USER 'aloha'@'%' IDENTIFIED BY '123456';

GRANT ALL PRIVILEGES ON *.* TO 'aloha'@'%' WITH GRANT OPTION;

FLUSH PRIVILEGES;

-- test sql 


DROP TABLE IF EXISTS test;
CREATE TABLE test (
	`no`   INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(100) NOT NULL,
	`age`  INT NULL DEFAULT 1,
	`main_title` TEXT NULL
);

SELECT *
FROM test
;

-- java 폴더 내 
jdbc 폴더, test 폴더 , db.properties 파일 존재

-- jdbc 폴더 내
annotation 폴더, config 폴더, dao 폴더, dto 폴더, utils 폴더

--annotation 폴더 내 
-- column.java 
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    boolean exist() default true;
}

-- Pk.java
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Pk {
	
}

-- Table.java
package com.alohaclass.jdbc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
	String value();
}



--  config 폴더 내

-- config.java
package com.alohaclass.jdbc.config;

import java.io.InputStream;
import java.util.Properties;


public class Config {
    public static boolean mapUnderscoreToCamelCase = false;
    public static boolean mapCamelCaseToUnderscore = false;
    public static boolean autoCommit = true;
    public static boolean sqlLog = true;
    public static String url = null;
    public static String username = null;
    public static String password = null;
   
    static {
        try (InputStream input = Config.class.getClassLoader().getResourceAsStream("db.properties")) {
            Properties prop = new Properties();
            if (input == null) {
                System.out.println("Sorry, unable to find db.properties");
            }
            prop.load(input);
            url = prop.getProperty("db.url");
            username = prop.getProperty("db.username");
            password = prop.getProperty("db.password");
            mapUnderscoreToCamelCase = Boolean.parseBoolean(prop.getProperty("mapUnderscoreToCamelCase", "false"));
            mapCamelCaseToUnderscore = Boolean.parseBoolean(prop.getProperty("mapCamelCaseToUnderscore", "false"));
            sqlLog = Boolean.parseBoolean(prop.getProperty("sql.log", "true"));
            autoCommit = Boolean.parseBoolean(prop.getProperty("autoCommit", "true"));
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

}

--  dao 폴더 내 

-- BaseDAO.java
package com.alohaclass.jdbc.dao;

import java.sql.ResultSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;

/**
 * BaseDAO - DAO
 */
public interface BaseDAO<T> {

	// 테이블명
	String table();

	// PK (no or id)
	String pk();

	// 매핑
	T map(ResultSet rs) throws Exception;

	// 검색옵션 조건
//	String getSearchOptions(List<String > searchOptions) throws Exception;
	default String getSearchOptions(List<String> searchOptions) throws Exception {
		if (searchOptions == null || searchOptions.size() == 0) {
			return "1=1";
		}
		String str = "";
		for (Iterator iterator = searchOptions.iterator(); iterator.hasNext();) {
			String column = (String) iterator.next();
			str += (column + " LIKE CONCAT('%', ?, '%') ");
			if (iterator.hasNext())
				str += " OR ";
		}
		return str;
	}

	// 필터옵션 정렬
//	String getFilterOptions(Map<String, String> filterOptions) throws Exception;
	default String getFilterOptions(Map<String, String> filterOptions) throws Exception {
		String str = " ORDER BY ";
		Set<String> keys = filterOptions.keySet();
		for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
			String key = (String) iterator.next();
			String value = filterOptions.get(key);
			str += (key + " " + value); // title ASC, writer DESC ...
			if (iterator.hasNext())
				str += ", ";
		}
		return str;
	}

	// 목록
	List<T> list() throws Exception;

	List<T> listBy(Map<String, Object> fields) throws Exception;

	// 페이징
	PageInfo<T> page() throws Exception;

	PageInfo<T> page(PageInfo<T> pageInfo) throws Exception;

	PageInfo<T> page(Page page) throws Exception;

	PageInfo<T> page(Page page, Map<String, String> filterOptions) throws Exception;

	PageInfo<T> page(Page page, String keyword, List<String> searchOptions) throws Exception;

	PageInfo<T> page(Page page, String keyword, List<String> searchOptions, Map<String, String> filterOptions)
			throws Exception;

	/**
	 * select - pk 기준으로 조회
	 * 
	 * @param pk
	 * @return
	 * @throws Exception
	 */
	T select(Object pk) throws Exception;

	/**
	 * selectBy - 1개 이상의 필드를 기준으로 조회
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T selectBy(Map<String, Object> fields) throws Exception;

	/**
	 * where == selectBy - 이름만 쉽게
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T where(Map<String, Object> fields) throws Exception;

	List<T> in(String col, String fields) throws Exception;

	List<T> in(String col, String... field) throws Exception;

	List<T> in(String col, List<String> fieldList) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String fields) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String... field) throws Exception;

	PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, List<String> fieldList) throws Exception;

	/**
	 * insert - null 이 아닌 필드만 insert
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int insert(T entity) throws Exception;

	/**
	 * insert - 지정한 필드만 insert
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int insert(T entity, String... fieldNames) throws Exception;

	/**
	 * insertKey - insert 후, 생성된 key 를 객체에 지정하여 반환
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	T insertKey(T entity) throws Exception;

	/**
	 * insertKey - 지정한 필드만 insert, 생성된 key 를 객체에 지정하여 반환
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	T insertKey(T entity, String... fieldNames) throws Exception;

	/**
	 * update - pk 조건으로 update
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int update(T entity) throws Exception;

	/**
	 * update - 지정한 필드만 update
	 * 
	 * @param entity
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int update(T entity, String... fields) throws Exception;
	
	/**
	 * update - 1개 이상의 필드를 기준으로 조회
	 * @param entity
	 * @param map
	 * @return
	 * @throws Exception
	 */
	int updateBy(T entity, Map<String, Object> map) throws Exception;

	/**
	 * delete - pk 를 기준으로 delete
	 * 
	 * @param entity
	 * @return
	 * @throws Exception
	 */
	int delete(Object pk) throws Exception;

	/**
	 * delete - 1개 이상의 필드를 기준으로 삭제
	 * 
	 * @param fields
	 * @return
	 * @throws Exception
	 */
	int deleteBy(Map<String, Object> fields) throws Exception;

	/**
	 * 개수 - 전체
	 * 
	 * @return
	 * @throws Exception
	 */
	int count() throws Exception;

	/**
	 * 개수 - 페이징(검색) 조건
	 * 
	 * @param pageInfo
	 * @return
	 * @throws Exception
	 */
	int count(PageInfo<T> pageInfo) throws Exception;

	/**
	 * 개수 - 검색 조건
	 * 
	 * @param keyword
	 * @param searchOptions
	 * @return
	 * @throws Exception
	 */
	int count(String keyword, List<String> searchOptions) throws Exception;

}


-- BaseDAOImpl.java
package com.alohaclass.jdbc.dao;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.annotation.Column;
import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;
import com.alohaclass.jdbc.config.Config;
import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.jdbc.utils.StringUtil;

public abstract class BaseDAOImpl<T> extends JDBConnection implements BaseDAO<T> {

	public String table() {
		// 제네릭 타입 T의 실제 클래스 얻기
		Class<T> clazz = getGenericType();

		// 어노테이션에서 테이블 이름 추출
		if (clazz.isAnnotationPresent(Table.class)) {
			Table table = clazz.getAnnotation(Table.class);
			return table.value();
		}

		throw new IllegalStateException("클래스 " + clazz.getSimpleName() + "에 @Table 어노테이션이 없습니다.");
	}

	public String pk() {
		Class<T> clazz = getGenericType();
		for (Field field : clazz.getDeclaredFields()) {
			if (field.isAnnotationPresent(Pk.class)) {
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				return fieldName;
			}
		}
		throw new IllegalStateException("클래스 " + clazz.getSimpleName() + "에 @Pk 필드가 없습니다.");
	}

	@SuppressWarnings("unchecked")
	private Class<T> getGenericType() {
		return (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
	}

	public T map(ResultSet rs) throws Exception {
		ParameterizedType superclass = (ParameterizedType) getClass().getGenericSuperclass();
		Class<T> clazz = (Class<T>) superclass.getActualTypeArguments()[0];
		T entity = clazz.getDeclaredConstructor().newInstance();
		Field[] fields = clazz.getDeclaredFields();
		for (Field field : fields) {
			field.setAccessible(true);
			// @Column(exist = false)이면 skip
			Column annotation = field.getAnnotation(Column.class);
			if (annotation != null && !annotation.exist()) {
				continue;
			}
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (field.getType().equals(String.class)) {
				field.set(entity, rs.getString(fieldName));
			} else if (field.getType().equals(Boolean.class) || field.getType().equals(boolean.class)) {
				field.set(entity, rs.getBoolean(fieldName));
			} else if (field.getType().equals(Long.class) || field.getType().equals(long.class)) {
				field.set(entity, rs.getLong(fieldName));
			} else if (field.getType().equals(Integer.class) || field.getType().equals(int.class)) {
				field.set(entity, rs.getInt(fieldName));
			} else if (field.getType().equals(Date.class)) {
				field.set(entity, rs.getTimestamp(fieldName));
			} else if (field.getType().equals(Double.class) || field.getType().equals(double.class)) {
				field.set(entity, rs.getDouble(fieldName));
			} else if (field.getType().equals(Float.class) || field.getType().equals(float.class)) {
				field.set(entity, rs.getFloat(fieldName));
			}
		}
		return entity;
	}

	@Override
	public List<T> list() throws Exception {
		String sql = " SELECT * FROM " + table();
		List<T> list = new ArrayList<T>();
		try {
			stmt = con.createStatement();
			log(sql);
			rs = stmt.executeQuery(sql);
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - list() 조회 중 에러");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> listBy(Map<String, Object> fields) throws Exception {
		StringBuilder sql = new StringBuilder("SELECT * FROM " + table() + " WHERE ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			String fieldName = entry.getKey();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(fieldName).append(" = ?");
			first = false;
		}

		List<T> list = new ArrayList<>();
		try {
			psmt = con.prepareStatement(sql.toString());

			int index = 1;
			StringBuilder paramLog = new StringBuilder("param (?) : ");
			for (Object value : fields.values()) {
				paramLog.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}

			log(sql, paramLog);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			return list;
		} catch (Exception e) {
			System.err.println(table() + " - listBy(Map<String, Object> fields) 조회 중 에러");
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public PageInfo<T> page() throws Exception {
		int total = count();
		Page page = new Page(total);

		String sql = " SELECT * FROM " + table() + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(PageInfo<T> pageInfo) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1" + "   AND ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count();
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String sql = " SELECT * " + " FROM " + table() + " LIMIT ?, ? ";
		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page() 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, Map<String, String> filterOptions) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count();
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String orderBy = getFilterOptions(filterOptions);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + orderBy + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, filterOptions) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, String keyword, List<String> searchOptions) throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count(keyword, searchOptions);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(searchOptions);
		int searchCounditionCount = searchOptions == null ? 0 : searchOptions.size();
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1" + "   AND ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, keyword, searchOptions) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> page(Page page, String keyword, List<String> searchOptions, Map<String, String> filterOptions)
			throws Exception {
		if (page == null || page.getTotal() == 0) {
			int total = count(keyword, searchOptions);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}

		String searchCondition = getSearchOptions(searchOptions);
		String AND = " AND ( " + searchCondition + " )";

		if ((keyword == null || keyword.equals("")) || (searchOptions == null || searchOptions.size() == 0)) {
			AND = "";
		}
		int searchCounditionCount = searchOptions == null ? 0 : searchOptions.size();
		String orderBy = getFilterOptions(filterOptions);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + AND + orderBy + " LIMIT ?, ? ";

		PageInfo<T> pageInfo = new PageInfo<>();
		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);

			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - page(page, keyword, searchOptions, filterOptions) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public T select(Object pk) throws Exception {
		String sql = "SELECT * FROM " + table() + " WHERE " + pk() + " = ?";
		StringBuilder param = new StringBuilder("param (?) : (1)").append(pk.toString()).append(" ");

		try {
			psmt = con.prepareStatement(sql);
			setPreparedStatementValue(psmt, 1, pk); // 중복 제거
			log(new StringBuilder(sql), param);

			rs = psmt.executeQuery();
			if (rs.next()) {
				return map(rs); // 조회된 row -> entity로 변환
			}
		} catch (Exception e) {
			System.err.println(table() + " - select(pk) 조회 중 에러");
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public T where(Map<String, Object> fields) throws Exception {
		return selectBy(fields);
	}

	@Override
	public T selectBy(Map<String, Object> fields) throws Exception {
		StringBuilder sql = new StringBuilder("SELECT * FROM " + table() + " WHERE ");
		StringBuilder param = new StringBuilder("param (?) : ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(entry.getKey()).append(" = ?");
			first = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());

			int index = 1;
			for (Map.Entry<String, Object> entry : fields.entrySet()) {
				Object value = entry.getValue();
				param.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value); // 중복 제거
			}

			log(sql, param);

			rs = psmt.executeQuery();
			if (rs.next()) {
				return map(rs);
			}
		} catch (Exception e) {
			System.err.println(table() + " - selectBy(Map<String, Object>) 조회 중 에러");
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * IN 조건 값들을 '' 로 묶어서 반환
	 * 
	 * @param col
	 * @param fields
	 * @return
	 */
	private String getInCondition(String col, String fields) {
		if (fields == null || fields.isEmpty()) {
			return "";
		}
		if (!fields.contains(",")) {
			return "AND " + col + " IN ( '" + fields + "' ) ";
		}
		String[] fieldArray = fields.split(",");
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fieldArray) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	private String getInConditions(String col, String... fields) {
		if (fields == null || fields.length == 0) {
			return "";
		}
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fields) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	private String getInConditions(String col, List<String> fieldList) {
		if (fieldList == null || fieldList.isEmpty()) {
			return "";
		}
		StringBuilder formattedFields = new StringBuilder();
		for (String field : fieldList) {
			if (formattedFields.length() > 0) {
				formattedFields.append(", ");
			}
			formattedFields.append("'").append(field.trim()).append("'");
		}
		return "AND " + col + " IN ( " + formattedFields.toString() + " ) ";
	}

	@Override
	public List<T> in(String col, String fields) throws Exception {
		String IN = getInCondition(col, fields);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> in(String col, String... field) throws Exception {
		String IN = getInConditions(col, field);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public List<T> in(String col, List<String> fieldList) throws Exception {
		String IN = getInConditions(col, fieldList);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN;

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return list;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String fields) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInCondition(col, fields);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, String... field) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInConditions(col, field);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public PageInfo<T> inAndPage(PageInfo<T> pageInfo, String col, List<String> fieldList) throws Exception {
		Page page = pageInfo.getPage();
		if (page == null || page.getTotal() == 0) {
			int total = count(pageInfo);
			if (page == null)
				page = new Page();
			page.setTotal(total);
		}
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchCounditionCount = pageInfo.getSearchOptions().size();

		String IN = getInConditions(col, fieldList);
		String sql = " SELECT * " + " FROM " + table() + " WHERE 1=1 " + IN + " AND   ( " + searchCondition + "       )"
				+ " LIMIT ?, ? ";

		List<T> list = new ArrayList<T>();
		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchCounditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			psmt.setInt(index++, page.getIndex());
			psmt.setInt(index++, page.getSize());
			log(sql);
			rs = psmt.executeQuery();
			while (rs.next()) {
				T entity = map(rs);
				list.add(entity);
			}
			pageInfo.setPage(page);
			pageInfo.setList(list);
		} catch (Exception e) {
			System.err.println(table() + " - inAndPage(PageInfo<T> pageInfo, String col, String fields) 조회 중 에러");
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public int insert(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		for (Field field : fields) {
			field.setAccessible(true);

			Column tableField = field.getAnnotation(Column.class);
			if (tableField != null && !tableField.exist()) {
				continue;
			}

			Object value = field.get(entity);

			if (value != null && !isDefaultValue(value)) {
				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;

			for (Field field : fields) {
				field.setAccessible(true);

				Column tableField = field.getAnnotation(Column.class);
				if (tableField != null && !tableField.exist()) {
					continue;
				}

				Object value = field.get(entity);

				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // 중복 제거
				}
			}
			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	private boolean isDefaultValue(Object value) {
		if (value instanceof Long) {
			return (Long) value == 0;
		} else if (value instanceof Boolean) {
			return !(Boolean) value;
		} else if (value instanceof Integer) {
			return (Integer) value == 0;
		} else if (value instanceof Double) {
			return (Double) value == 0.0;
		} else if (value instanceof Float) {
			return (Float) value == 0.0f;
		}
		return false;
	}

	@Override
	public int insert(T entity, String... fieldNames) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;
		for (String fieldName : fieldNames) {
			Field field = fieldMap.get(fieldName);
			if (field != null) {
				Column tableField = field.getAnnotation(Column.class);
				if (tableField != null && !tableField.exist()) {
					continue; // DB에 존재하지 않는 필드는 건너뜀
				}

				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}

				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;

			for (String fieldName : fieldNames) {
				Field field = fieldMap.get(fieldName);
				if (field != null) {
					Column tableField = field.getAnnotation(Column.class);
					if (tableField != null && !tableField.exist()) {
						continue;
					}

					field.setAccessible(true);
					Object value = field.get(entity);

					setPreparedStatementValue(psmt, index++, value); // 중복 제거!
				}
			}
			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity, String...) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public T insertKey(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		for (Field field : fields) {
			field.setAccessible(true);

			// 🔹 TableField(exist = false) 필드 건너뛰기
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			Object value = field.get(entity);
			if (value != null && !isDefaultValue(value)) {
				if (!first) {
					sql.append(", ");
					placeholders.append(", ");
				}
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				sql.append(fieldName);
				placeholders.append("?");
				first = false;
			}
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			// 🔹 PreparedStatement 생성
			// 🔸 Statement.RETURN_GENERATED_KEYS 옵션을 사용하여 AUTO_INCREMENT 키를 가져올 수 있도록 설정
			psmt = con.prepareStatement(sql.toString(), Statement.RETURN_GENERATED_KEYS);
			int index = 1;

			for (Field field : fields) {
				field.setAccessible(true);

				// 🔹 TableField(exist = false) 필드 건너뛰기
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				Object value = field.get(entity);
				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // 중복 제거!
				}
			}

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity) 도중 에러");
			e.printStackTrace();
		}

		// 🔹 AUTO_INCREMENT key 설정
		Long genKey = 0L;
		try (ResultSet generatedKeys = psmt.getGeneratedKeys()) {
			if (generatedKeys.next()) {
				genKey = generatedKeys.getLong(1);
				// Underscore to CamelCase 변환
				String pk = pk();
				if (Config.mapUnderscoreToCamelCase) {
					pk = StringUtil.convertUnderscoreToCamelCase(pk);
				}
				Field pkField = entity.getClass().getDeclaredField(pk);
				pkField.setAccessible(true);
				if (pkField.getType().equals(Long.class) || pkField.getType().equals(long.class)) {
					pkField.set(entity, genKey);
				} else if (pkField.getType().equals(Integer.class) || pkField.getType().equals(int.class)) {
					pkField.set(entity, genKey.intValue());
				} else if (pkField.getType().equals(String.class)) {
					pkField.set(entity, genKey.toString());
				} else {
					pkField.set(entity, genKey);
				}
				System.out.println("genKey : " + genKey);
			}
		} catch (Exception e) {
			System.err.println(table() + " - insertKey(entity) 도중 에러");
			e.printStackTrace();
		}

		return entity;
	}

	@Override
	public T insertKey(T entity, String... fieldNames) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("INSERT INTO " + table() + " (");
		StringBuilder placeholders = new StringBuilder(" VALUES (");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;
		for (String fieldName : fieldNames) {
			Field field = fieldMap.get(fieldName);
			if (field == null)
				continue;

			// 🔹 TableField(exist = false) 필드 제외
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			if (!first) {
				sql.append(", ");
				placeholders.append(", ");
			}

			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}

			sql.append(fieldName);
			placeholders.append("?");
			first = false;
		}

		sql.append(") ");
		placeholders.append(")");
		sql.append(placeholders.toString());

		try {
			psmt = con.prepareStatement(sql.toString(), Statement.RETURN_GENERATED_KEYS);
			int index = 1;

			for (String fieldName : fieldNames) {
				Field field = fieldMap.get(fieldName);
				if (field == null)
					continue;

				// 🔹 TableField(exist = false) 필드 제외
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				field.setAccessible(true);
				Object value = field.get(entity);
				if (value != null && !isDefaultValue(value)) {
					setPreparedStatementValue(psmt, index++, value); // 중복 제거!
				}
			}

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - insert(entity, String...) 도중 에러");
			e.printStackTrace();
		}

		// AUTO_INCREMENT key 처리
		Long genKey = 0L;
		try (ResultSet generatedKeys = psmt.getGeneratedKeys()) {
			if (generatedKeys.next()) {
				genKey = generatedKeys.getLong(1);
				Field pkField = entity.getClass().getDeclaredField(pk());
				pkField.setAccessible(true);
				if (pkField.getType().equals(Long.class) || pkField.getType().equals(long.class)) {
					pkField.set(entity, genKey);
				} else if (pkField.getType().equals(Integer.class) || pkField.getType().equals(int.class)) {
					pkField.set(entity, genKey.intValue());
				} else if (pkField.getType().equals(String.class)) {
					pkField.set(entity, genKey.toString());
				} else {
					pkField.set(entity, genKey);
				}
				System.out.println("genKey : " + genKey);
			}
		} catch (Exception e) {
			System.err.println(table() + " - insertKey(entity) 도중 에러");
			e.printStackTrace();
		}

		return entity;
	}

	@Override
	public int update(T entity) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		StringBuilder whereClause = new StringBuilder(" WHERE " + pk() + " = ?");

		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;
		Object pkValue = null;

		for (Field field : fields) {
			field.setAccessible(true);

			// 🔹 존재하지 않는 필드 제외
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;

			Object value = field.get(entity);
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}

			if (fieldName.equals(pk())) {
				pkValue = value;
				continue;
			}

			if (value != null) {
				if (!first) {
					sql.append(", ");
				}
				sql.append(fieldName).append(" = ?");
				first = false;
			}
		}

		sql.append(whereClause);

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");

			for (Field field : fields) {
				field.setAccessible(true);

				// 🔹 존재하지 않는 필드 제외
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				Object value = field.get(entity);
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				if (fieldName.equals(pk())) {
					continue;
				}

				if (value != null) {
					param.append("(").append(index).append(")").append(value.toString()).append(" ");
					setPreparedStatementValue(psmt, index++, value); // 중복 제거!
				}
			}

			// WHERE 절의 pk 파라미터 세팅
			param.append("(").append(index).append(")").append(pkValue.toString()).append(" ");
			setPreparedStatementValue(psmt, index, pkValue);

			log(sql, param, pkValue.toString());
			result = psmt.executeUpdate();

		} catch (Exception e) {
			System.err.println(table() + " - update(entity) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int update(T entity, String... fields) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		StringBuilder whereClause = new StringBuilder(" WHERE " + pk() + " = ?");

		Map<String, Field> fieldMap = new HashMap<>();
		for (Field field : entity.getClass().getDeclaredFields()) {
			fieldMap.put(field.getName(), field);
		}

		boolean first = true;

		for (String fieldName : fields) {
			if (fieldMap.containsKey(fieldName)) {
				Field field = fieldMap.get(fieldName);

				// 🔹 존재하지 않는 필드 제외
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;

				field.setAccessible(true);
				Object value = field.get(entity);

				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}

				if (value != null) {
					if (!first)
						sql.append(", ");
					sql.append(fieldName).append(" = ?");
					first = false;
				}
			}
		}

		sql.append(whereClause);

		Field pkField = fieldMap.get(pk());
		pkField.setAccessible(true);
		Object pkValue = pkField.get(entity);

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");

			for (String fieldName : fields) {
				if (fieldMap.containsKey(fieldName)) {
					Field field = fieldMap.get(fieldName);

					// 🔹 존재하지 않는 필드 제외
					Column tf = field.getAnnotation(Column.class);
					if (tf != null && !tf.exist())
						continue;

					field.setAccessible(true);
					Object value = field.get(entity);

					if (field.getName().equals(pk())) {
						continue;
					}

					if (Config.mapCamelCaseToUnderscore) {
						fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
					}

					if (value != null) {
						param.append("(").append(index).append(")").append(value.toString()).append(" ");
						setPreparedStatementValue(psmt, index++, value); // 중복 제거!
					}
				}
			}

			// 🔸 WHERE 절 pk 바인딩
			param.append("(").append(index).append(")").append(pkValue.toString()).append(" ");
			if (pkValue instanceof String) {
				psmt.setString(index, (String) pkValue);
			} else if (pkValue instanceof Boolean) {
				psmt.setBoolean(index, (Boolean) pkValue);
			} else if (pkValue instanceof Long) {
				psmt.setLong(index, (Long) pkValue);
			} else if (pkValue instanceof Integer) {
				psmt.setInt(index, (Integer) pkValue);
			} else if (pkValue instanceof Double) {
				psmt.setDouble(index, (Double) pkValue);
			} else if (pkValue instanceof Float) {
				psmt.setFloat(index, (Float) pkValue);
			} else if (pkValue instanceof java.util.Date) {
				psmt.setDate(index, new java.sql.Date(((java.util.Date) pkValue).getTime()));
			} else {
				psmt.setObject(index, pkValue);
			}

			log(sql, param, pkValue.toString());
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - update(entity, String...) 도중 에러");
			e.printStackTrace();
		}

		return result;
	}

	@Override
	public int updateBy(T entity, Map<String, Object> map) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("UPDATE " + table() + " SET ");
		Field[] fields = entity.getClass().getDeclaredFields();
		boolean first = true;

		// SET절 구성 (PK 제외, null 제외)
		for (Field field : fields) {
			field.setAccessible(true);
			Column tf = field.getAnnotation(Column.class);
			if (tf != null && !tf.exist())
				continue;
			String fieldName = field.getName();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (fieldName.equals(pk()))
				continue;
			Object value = field.get(entity);
			if (value != null) {
				if (!first)
					sql.append(", ");
				sql.append(fieldName).append(" = ?");
				first = false;
			}
		}

		// WHERE절 구성
		sql.append(" WHERE ");
		boolean firstCond = true;
		for (String key : map.keySet()) {
			String fieldName = key;
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!firstCond)
				sql.append(" AND ");
			sql.append(fieldName).append(" = ?");
			firstCond = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder param = new StringBuilder("param (?) : ");
			// SET절 파라미터 바인딩
			for (Field field : fields) {
				field.setAccessible(true);
				Column tf = field.getAnnotation(Column.class);
				if (tf != null && !tf.exist())
					continue;
				String fieldName = field.getName();
				if (Config.mapCamelCaseToUnderscore) {
					fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
				}
				if (fieldName.equals(pk()))
					continue;
				Object value = field.get(entity);
				if (value != null) {
					param.append("(").append(index).append(")").append(value).append(" ");
					setPreparedStatementValue(psmt, index++, value);
				}
			}
			// WHERE절 파라미터 바인딩
			for (Object value : map.values()) {
				param.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}
			log(sql, param);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - updateBy(entity, map) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(Object pk) throws Exception {
		int result = 0;
		String sql = "DELETE FROM " + table() + " WHERE " + pk() + " = ?";

		try {
			psmt = con.prepareStatement(sql);
			setPreparedStatementValue(psmt, 1, pk); // 🔹 타입별 분기 공통 메서드로 분리

			log(sql);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - delete(pk) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int deleteBy(Map<String, Object> fields) throws Exception {
		int result = 0;
		StringBuilder sql = new StringBuilder("DELETE FROM " + table() + " WHERE ");
		boolean first = true;

		for (Map.Entry<String, Object> entry : fields.entrySet()) {
			String fieldName = entry.getKey();
			if (Config.mapCamelCaseToUnderscore) {
				fieldName = StringUtil.convertCamelCaseToUnderscore(fieldName);
			}
			if (!first) {
				sql.append(" AND ");
			}
			sql.append(fieldName).append(" = ?");
			first = false;
		}

		try {
			psmt = con.prepareStatement(sql.toString());
			int index = 1;
			StringBuilder paramLog = new StringBuilder("param (?) : ");

			for (Object value : fields.values()) {
				paramLog.append("(").append(index).append(")").append(value).append(" ");
				setPreparedStatementValue(psmt, index++, value);
			}

			log(sql, paramLog);
			result = psmt.executeUpdate();
		} catch (Exception e) {
			System.err.println(table() + " - deleteBy(Map<String, Object> fields) 도중 에러");
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int count() throws Exception {
		int total = 0;
		String sql = "SELECT COUNT(*) FROM " + table();
		try {
			stmt = con.createStatement();
			rs = stmt.executeQuery(sql);
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count() 조회 중 에러");
			e.printStackTrace();
		}
		return total;
	}

	@Override
	public int count(PageInfo<T> pageInfo) throws Exception {
		int total = 0;
		String searchCondition = getSearchOptions(pageInfo.getSearchOptions());
		int searchConditionCount = pageInfo.getSearchOptions().size();
		String sql = "SELECT COUNT(*) FROM " + table() + " WHERE 1=1 AND (" + searchCondition + ")";

		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchConditionCount; i++) {
				psmt.setString(index++, pageInfo.getKeyword());
			}
			rs = psmt.executeQuery();
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count(PageInfo<T> pageInfo) 조회 중 에러");
			e.printStackTrace();
		}
		return total;
	}

	@Override
	public int count(String keyword, List<String> searchOptions) throws Exception {
		int total = 0;
		String searchCondition = getSearchOptions(searchOptions);
		int searchConditionCount = searchOptions == null ? 0 : searchOptions.size();
		String sql = "SELECT COUNT(*) FROM " + table() + " WHERE 1=1 AND (" + searchCondition + ")";

		try {
			psmt = con.prepareStatement(sql);
			int index = 1;
			for (int i = 0; i < searchConditionCount; i++) {
				psmt.setString(index++, keyword);
			}
			rs = psmt.executeQuery();
			if (rs.next()) {
				total = rs.getInt(1);
			}
		} catch (Exception e) {
			System.err.println(table() + " - count(keyword, searchOptions) 조회 중 에러");
			e.printStackTrace();
		}
		return total;

	}

	/**
	 * SQL 로그
	 * 
	 * @param sql
	 */
	public void log(String sql) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql.toString());
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql, StringBuilder param) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println(param.toString());
			System.out.println("==================================================");
		}
	}

	public void log(StringBuilder sql, StringBuilder param, String pk) {
		if (Config.sqlLog) {
			System.out.println("[SQL] - alcl.jdbc");
			System.out.println("==================================================");
			System.out.println(sql);
			System.out.println(param.toString());
			System.out.println("pk - " + pk() + " : " + pk);
			System.out.println("==================================================");
		}
	}

	// 🔸 타입 분기 공통화
	private void setPreparedStatementValue(PreparedStatement ps, int index, Object value) throws SQLException {
		if (value instanceof String) {
			ps.setString(index, (String) value);
		} else if (value instanceof Boolean) {
			ps.setBoolean(index, (Boolean) value);
		} else if (value instanceof Long) {
			ps.setLong(index, (Long) value);
		} else if (value instanceof Integer) {
			ps.setInt(index, (Integer) value);
		} else if (value instanceof Double) {
			ps.setDouble(index, (Double) value);
		} else if (value instanceof Float) {
			ps.setFloat(index, (Float) value);
		} else if (value instanceof Date) {
			Date dateValue = (Date) value;
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateValue);
			Timestamp timestampValue = new Timestamp(cal.getTimeInMillis());
			ps.setTimestamp(index, timestampValue);
		} else {
			ps.setObject(index, value);
		}
	}

}

-- JDBConnection.java
package com.alohaclass.jdbc.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;

import com.alohaclass.jdbc.config.Config;

public class JDBConnection {
    
    public Connection con;                // 연결된 드라이버에 SQL을 요청할 객체를 생성하는 클래스
    public Statement stmt;                // SQL 실행 요청을 하는 클래스
    public PreparedStatement psmt;        // Statement 에서 ? 파라미터 확장기능을 추가로 제공하는 클래스
    public ResultSet rs;                // SQL 실행 결과를 받아오는 클래스
    
    // 기본 생성자
    public JDBConnection() {
        // JDBC 드라이버 로드
        // MySQL
        try {
            // mysql-connector-j.xxx.jar 드라이버의 클래스를 로드한다.
            Class.forName("com.mysql.cj.jdbc.Driver");         
            con = DriverManager.getConnection(Config.url, Config.username, Config.password);
            // Auto Commit 여부 설정
        	try {
    			con.setAutoCommit(Config.autoCommit);
    			// System.out.println("Auto Commit : " + Config.autoCommit);
        	} catch (Exception e) {
        		System.err.println("Auto Commit 설정 실패");
        	}
            	
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


-- dto 폴더 내 

-- Entitiy.java 
package com.alohaclass.jdbc.dto;

import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;

public class Entity {
    public String tableName;
    public String pk;
    
    public Entity() {
		initializeTableName();
		initializePk();
	}
	
	public void initializePk() {
		// 특정 변수 위에 @Pk 붙어 있으면 그 변수를 pk로 설정
		Class<?> clazz = this.getClass();
		if (clazz.isAnnotationPresent(Pk.class)) {
			Pk pk = clazz.getAnnotation(Pk.class);
			this.pk = pk.toString();
		}
	}
    
    public void initializeTableName() {
        Class<?> clazz = this.getClass();
        if (clazz.isAnnotationPresent(Table.class)) {
            Table table = clazz.getAnnotation(Table.class);
            this.tableName = table.value();
        }
    }
    

    public String getTableName() {
        return tableName;
    }

    public String getPk() {
        return pk;
    }
    
    
}




-- Page.java


--  utils 폴더
package com.alohaclass.jdbc.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * [페이징]
 * ✅ 페이지 필수 정보
 * 페이지 번호          : 
 * 페이지당 게시글 수       
 * 노출 페이지 개수
 * 전체 데이터 개수
 * 
 * ⭐ 페이지 수식 정보
 * 시작 번호
 * 끝 번호
 * 첫 번호
 * 마지막 번호       
 */
@Data
@AllArgsConstructor
// @Builder  // 버그나는 버전이 있어서 제외
public class Page {

    // 페이징 기본값
    public static final int PAGE = 1;  		// 현재 페이지 번호 기본값
    public static final int SIZE = 10;      // 페이지당 게시글 수 기본값
    public static final int COUNT = 10;     // 노출 페이지 개수 기본값


    // ✅ 필수 정보
    private int page;   // 페이지 번호
    private int size;   // 페이지당 글 수
    private int count;  // 노출 페이지 개수
    private int total;  // 전체 데이터 개수

    // ⭐ 수식 정보
    private int start;  // 시작 번호
    private int end;    // 끝 번호
    private int first;  // 첫 번호
    private int last;   // 마지막 번호

    private int prev;   // 이전 번호
    private int next;   // 다음 번호

    private int index;  // 데이터 순서 번호

    // 생성자
    public Page() {
        this(0);
    }

    // 데이터 개수
    public Page(int total) {
        this(PAGE, total);
    }

    // 현재 번호, 데이터 개수
    public Page(int page, int total) {
        this(page, SIZE, COUNT, total);
    }

    public Page(int page, int size, int count, int total) {
        this.page = page;
        this.size = size;
        this.count = count;
        this.total = total;
        calc();
    }

    // setter
    // - 데이터 개수 지정 후, 페이징 수식 재계산
    public void setTotal(int total) {
        this.total = total;
        calc();
    } 

    // 페이징 처리 수식
    public void calc() {
        // 첫 번호
        this.first = 1;
        // 마지막 번호
        this.last = (this.total - 1) / size + 1;
        // 시작 번호
        this.start = ( (page-1) / count ) * count + 1;
        // 끝 번호
        this.end = ( (page-1) / count + 1 ) * count;
        if( this.end > this.last ) this.end = this.last;

        // 이전 번호
        this.prev = this.page - 1;
        // 다음 번호
        this.next = this.page + 1;
        // 데이터 순서 번호(index)
        this.index = (this.page - 1) * this.size;
    }
    
}

-- PageInfo.java
package com.alohaclass.jdbc.dto;

import java.util.List;
import java.util.Map;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 페이징
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class PageInfo<T> {
	
	Page page;								// 페이징
	List<T> list;							// 데이터 목록
	String keyword;							// 검색어
	List<String> searchOptions;		// 검색 옵션 (title, writer, content, ...)
    Map<String, String> filterOptions;		// 필터 옵션
    
}

-- utils 폴더 내 

-- StringUtil.java
package com.alohaclass.jdbc.utils;

public class StringUtil {
	
	// camel --> underscore
	// * sampleObject --> sample_object
	public static String convertCamelCaseToUnderscore(String camelCase) {
        StringBuilder result = new StringBuilder();
        for (char c : camelCase.toCharArray()) {
            if (Character.isUpperCase(c)) {
                result.append('_').append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
	
	
	// underscore --> camel  
	// * sample_object --> sampleObject
	public static String convertUnderscoreToCamelCase(String underscore) {
		StringBuilder result = new StringBuilder();
		boolean nextUpperCase = false;
		for (char c : underscore.toCharArray()) {
			if (c == '_') {
				nextUpperCase = true;
			} else {
				if (nextUpperCase) {
					result.append(Character.toUpperCase(c));
					nextUpperCase = false;
				} else {
					result.append(c);
				}
			}
		}
		return result.toString();
	}
}



-- test 폴더 내

DAO 폴더, DTO 폴더, Service 폴더 존재

-- DAO 폴더 내

-- BoardDAO.java
package com.alohaclass.test.DAO;


import com.alohaclass.jdbc.dao.BaseDAOImpl;
import com.alohaclass.test.DTO.Board;

public class BoardDAO extends BaseDAOImpl<Board> {

	

}


-- TestDAO.java 
package com.alohaclass.test.DAO;

import java.sql.ResultSet;

import com.alohaclass.jdbc.dao.BaseDAOImpl;
import com.alohaclass.test.DTO.Test;

public class TestDAO extends BaseDAOImpl<Test> {

	@Override
	public Test map(ResultSet rs) throws Exception {
		Test test = new Test();
		test.setName( rs.getString("name") );
		test.setAge( rs.getInt("age") );
		return test;
	}

	@Override
	public String pk() {
		return "no";
	}

	@Override
	public String table() {
		return "test";
	}

}


-- DTO 폴더 내

-- Board.java 
package com.alohaclass.test.DTO;

import java.util.Date;

import com.alohaclass.jdbc.annotation.Pk;
import com.alohaclass.jdbc.annotation.Table;
import com.alohaclass.jdbc.annotation.Column;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Table("board")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Board {

	@Pk
	private Long boardNo;			// 기본키
	private String id;
	private String title;
	private String writer;
	private String content;
	private Date date;
	private Date createdAt;
	private Date updatedAt;
	
	@Column(exist = false)		// 실제 DB 컬럼에 없는 변수
	private String test;
	

}


-- Test.java 
package com.alohaclass.test.DTO;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Test {
	private int no;
	private String name;
	private int age;
	private String mainTitle;
}


-- Service 폴더 내 

-- BoardService.java 
package com.alohaclass.test.Service;

import java.util.List;

import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DTO.Board;

public interface BoardService {
	
	// C.R.U.D
	public List<Board> list();
	public PageInfo<Board> page();
	public Board select(int no);
	public Board selectById(String id);
	public int insert(Board Board);
	public Board insertKey(Board Board);
	public int update(Board Board);
	public int delete(int no);

}


-- BoardServiceImpl.java 
package com.alohaclass.test.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DAO.BoardDAO;
import com.alohaclass.test.DTO.Board;

public class BoardServiceImpl implements BoardService {
	
	BoardDAO boardDAO = new BoardDAO();

	@Override
	public List<Board> list() {
		List<Board> list = null;
		try {
			list = boardDAO.list();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}
	

	@Override
	public PageInfo<Board> page() {
		PageInfo<Board> pageInfo = null;
		try {
			Page page = new Page();
			page.setPage(1);
			page.setSize(10);
			// 방법1
			// pageInfo = boardDAO.page();
			// 방법2
			//pageInfo = testDAO.page(page);
			// 방법3
			String keyword = "검색어";
			List<String> searchOptions = List.of("title", "content");
			// pageInfo = boardDAO.page(page, keyword, searchOptions);
			// 방법4
			Map<String, String> filterOptions = new HashMap<String, String>() {{
	            put("title", "ASC");
	            put("writer", "DESC");
	        }};
	        boardDAO.page(page, keyword, searchOptions, filterOptions);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public Board select(int no) {
		Board board = null;
		try {
			board = boardDAO.select(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return board;
	}

	@Override
	public int insert(Board Board) {
		int result = 0;
		try {
			result = boardDAO.insert(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public Board insertKey(Board Board) {
		Board result = null;
		try {
			result = boardDAO.insertKey(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int update(Board Board) {
		int result = 0;
		try {
			result = boardDAO.update(Board);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(int no) {
		int result = 0;
		try {
			result = boardDAO.delete(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}


	@Override
	public Board selectById(String id) {
		Board board = null;
		try {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("id", id);
			board = boardDAO.selectBy(map);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return board;
	} 

}

-- TestService.java 
package com.alohaclass.test.Service;

import java.util.List;

import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DTO.Test;

public interface TestService {
	
	// C.R.U.D
	public List<Test> list();
	public PageInfo<Test> page();
	public Test select(int no);
	public int insert(Test test);
	public Test insertKey(Test test);
	public int update(Test test);
	public int delete(int no);

}

-- TestServiceImpl.java 
package com.alohaclass.test.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alohaclass.jdbc.dto.Page;
import com.alohaclass.jdbc.dto.PageInfo;
import com.alohaclass.test.DAO.TestDAO;
import com.alohaclass.test.DTO.Test;

public class TestServiceImpl implements TestService {
	
	TestDAO testDAO = new TestDAO();

	@Override
	public List<Test> list() {
		List<Test> list = null;
		try {
			list = testDAO.list();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return list;
	}
	
	@Override
	public PageInfo<Test> page() {
		PageInfo<Test> pageInfo = null;
		try {
			// 방법1
			// pageInfo = testDAO.page();
			// 방법2
			 Page page = new Page();
			 page.setPage(1);
			 page.setSize(10);
			// pageInfo = testDAO.page(page);
			// 방법3
			String keyword = "검색어";
			List<String> searchOptions = new ArrayList<String>();
			searchOptions.add("name");
			searchOptions.add("age");
			// pageInfo = testDAO.page(page, keyword, searchOptions);
			// 방법4
			Map<String, String> filterOptions = new HashMap<String, String>() {{
	            put("name", "ASC");
	            put("age", "DESC");
	        }};
			testDAO.page(page, keyword, searchOptions, filterOptions);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return pageInfo;
	}

	@Override
	public Test select(int no) {
		Test test = null;
		try {
			test = testDAO.select(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return test;
	}

	@Override
	public int insert(Test test) {
		int result = 0; 
		try {
			result = testDAO.insert(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
	
	@Override
	public Test insertKey(Test test) {
		try {
			test = testDAO.insertKey(test);
			System.out.println(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return test;
	}


	@Override
	public int update(Test test) {
		int result = 0;
		try {
			result = testDAO.update(test);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public int delete(int no) {
		int result = 0;
		try {
			result = testDAO.delete(no);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}

}

-- db.properties 
db.url=jdbc:mysql://127.0.0.1:3306/aloha?serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true&useSSL=false
db.username=aloha
db.password=123456
mapUnderscoreToCamelCase=true
mapCamelCaseToUnderscore=true
autoCommit=true
sqlLog=true


사용 라이브러리는 
jakarta.servlet-api-6.1.0
jakarta.servlet.jsp.jstl-3.0.1
jakarta.servlet.jsp.jstl-api-3.0.2
lombok
mysql-connector-j-9.0.0

